<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 4.0.4">
  <meta charset="utf-8">
  <title>Source: functions.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: functions.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>import { tag } from &quot;./helpers.js&quot;
import { _Set, Vec } from &quot;./classes.js&quot;

/** @namespace */
const type_checks &#x3D; {}

/** 
 * **[Global]** Checks if a value is a number or a big int
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isnum &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x &#x3D;&#x3D;&#x3D; &quot;number&quot; || typeof x &#x3D;&#x3D;&#x3D; &quot;bigint&quot;)

/** 
 * **[Global]** Same as the built in [Number.isInteger](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger)
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isint &#x3D; tag({ keep_global: true }, Number.isInteger)

/** 
 * **[Global]** Checks if a value is a string
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isstr &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x &#x3D;&#x3D;&#x3D; &quot;string&quot;)

/** 
 * **[Global]** Checks if a value is an array (alias for Array.isArray)
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
// Can&#x27;t use Array.isArray directly because the regex won&#x27;t pick up on it being niladic
type_checks.isarr &#x3D; tag({ keep_global: true }, x &#x3D;&gt; Array.isArray(x))

/** 
 * **[Global]** Checks if a value is a boolean
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isbool &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x &#x3D;&#x3D;&#x3D; &quot;boolean&quot;)

/** 
 * **[Global]** Checks if a value is a function
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isfunc &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x &#x3D;&#x3D;&#x3D; &quot;function&quot;)

/**
 * **[Global]** Checks if a value is an object
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isobj &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x &#x3D;&#x3D;&#x3D; &quot;object&quot;)

/** 
 * **[Global]** Gets the type of a value using typeof
 * @function
 * @param {any} value Value to get the type of
 * @returns {boolean}
 */
type_checks.type &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x)

/** 
 * **[Global]** Checks if a type is iterable
 * @function
 * @param {any} value Value to check
 * @returns {boolean}
 */
type_checks.isiter &#x3D; tag({ keep_global: true }, x &#x3D;&gt; typeof x[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot;)

/** @namespace */
const type_casts &#x3D; {}

/**
 * Casts a value to a number using the &#x60;Number&#x60; constructor. If &#x60;value&#x60; is a string
 * then a number will be extracted with regex before casting.
 * @param {any} value
 * @returns {number}
 */
type_casts.num &#x3D; value &#x3D;&gt; {
	if (type_checks.isstr(value)) {
		const match &#x3D; value.match(/-?\d+(\.\d+)?/)[0]
		return match ? Number(match) : null
	}

	return Number(value)
}

/**
 * Casts a value to an integer using parseInt. If &#x60;value&#x60; is a string an int
 * will be extracted with regex before casting).
 * @param {any} value Value to cast
 * @returns {number}
 */
type_casts.int &#x3D; value &#x3D;&gt; parseInt(type_casts.num(value))

/**
 * Casts a value to a string. If &#x60;value&#x60; is an array, it will be joined by &quot;&quot;.
 * @param {any} value Value to cast
 */
type_casts.str &#x3D; value &#x3D;&gt; {
	const str &#x3D; value?.toString()

	if (str &#x3D;&#x3D;&#x3D; null) return &quot;null&quot;
	if (str &#x3D;&#x3D;&#x3D; undefined) return &quot;undefined&quot;
	if (value instanceof Vec)
		return &#x60;Vec(${value.x}, ${value.y})&#x60;
	if (type_checks.isarr(value))
		return value.join(&quot;&quot;)
	if (type_checks.isobj(value))
		return str &#x3D;&#x3D;&#x3D; &quot;[object Object]&quot; ? JSON.stringify(value) : str

	return str
}

/**
 * Casts a value to an array. If &#x60;value&#x60; is a number, an array of length &#x60;value&#x60;
 * will be created
 * @param {any} value Value to cast
 * @returns {Array}
 */
type_casts.arr &#x3D; value &#x3D;&gt; {
	if (type_checks.isnum(value)) return Array(value)
	if (type_checks.isiter(value)) return [...value]
	return Array.from(value)
}

/**
 * Casts a value to a boolean (alias for Boolean constructor)
 * @param {any} value Value to cast
 * @returns {boolean}
 */
type_casts.bool &#x3D; value &#x3D;&gt; Boolean(value)

/** @namespace */
const math_utils &#x3D; {}

/** 
 * Casts &#x60;a&#x60; and &#x60;b&#x60; using &#x60;Number&#x60; constructor, then adds them using &#x60;+&#x60; operator
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.add &#x3D; (a, b) &#x3D;&gt; Number(a) + Number(b)

/** 
 * Casts &#x60;a&#x60; and &#x60;b&#x60; using &#x60;Number&#x60; constructor, then subtracts them using &#x60;-&#x60; operator
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.sub &#x3D; (a, b) &#x3D;&gt; Number(a) - Number(b)

/** 
 * Casts &#x60;a&#x60; and &#x60;b&#x60; using &#x60;Number&#x60; constructor, then multiplies them using &#x60;*&#x60; operator
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.mul &#x3D; (a, b) &#x3D;&gt; Number(a) * Number(b)

/** 
 * Casts &#x60;a&#x60; and &#x60;b&#x60; using &#x60;Number&#x60; constructor, then divides them using &#x60;/&#x60; operator
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.div &#x3D; (a, b) &#x3D;&gt; Number(a) / Number(b)

/** 
 * Casts &#x60;a&#x60; and &#x60;b&#x60; using &#x60;Number&#x60; constructor, then calculates &#x60;a % b&#x60; 
 * (note: this is not true modulo, just remainder after division)
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.mod &#x3D; (a, b) &#x3D;&gt; Number(a) % Number(b)

/** 
 * Calculates &#x60;b ** m&#x60; (optionally modulo &#x60;m&#x60;)
 * @param {number} b
 * @param {number} e
 * @param {number} [m]
 * @return {number}
 */
math_utils.exp &#x3D; (b, e, m &#x3D; null) &#x3D;&gt; {
	if (m) {
		// naive solution but it does the job
		if (m &#x3D;&#x3D; 1) return 0
		let ret &#x3D; 1
		for (let i &#x3D; 0; i &amp;lt; e; i++)
			ret &#x3D; (ret * b) % m
		return ret
	} else return b ** e
}

/**
 * Returns the absolute difference between &#x60;a&#x60; and &#x60;b&#x60;
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
math_utils.absdiff &#x3D; (a, b) &#x3D;&gt; Math.abs(a - b)

/**
 * Checks if &#x60;a&#x60; is greater than &#x60;b&#x60;
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
math_utils.gt &#x3D; (a, b) &#x3D;&gt; a &gt; b

/**
 * Checks if &#x60;a&#x60; is less than &#x60;b&#x60;
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
math_utils.lt &#x3D; (a, b) &#x3D;&gt; a &amp;lt; b

/**
 * Checks if &#x60;a&#x60; is greater than or equal to &#x60;b&#x60;
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
math_utils.gte &#x3D; (a, b) &#x3D;&gt; a &gt;&#x3D; b

/**
 * Checks if &#x60;a&#x60; is less than or equal to &#x60;b&#x60;
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
math_utils.lte &#x3D; (a, b) &#x3D;&gt; a &amp;lt;&#x3D; b

/**
 * Checks if &#x60;n&#x60; is odd
 * @param {number} n
 * @returns {boolean}
 */
math_utils.odd &#x3D; n &#x3D;&gt; n % 2 &#x3D;&#x3D;&#x3D; 1

/**
 * Checks if &#x60;n&#x60; is even
 * @param {number} n
 * @returns {boolean}
 */
math_utils.even &#x3D; n &#x3D;&gt; n % 2 &#x3D;&#x3D;&#x3D; 0

/**
 * Calculates the absolute value of &#x60;n&#x60;
 * @param {number} n
 * @returns {number}
 */
math_utils.abs &#x3D; n &#x3D;&gt; Math.abs(n)

/**
 * Calculates the square root of &#x60;n&#x60;
 * @param {number} n
 * @returns {number}
 */
math_utils.sqrt &#x3D; n &#x3D;&gt; Math.sqrt(n)

/**
 * Calculates the sign of &#x60;n&#x60;
 * @param {number} n
 * @returns {number}
 */
math_utils.sign &#x3D; n &#x3D;&gt; Math.sign(n)

/**
 * Rounds &#x60;n&#x60; down to the nearest integer
 * @param {number} n
 * @returns {number}
 */
math_utils.floor &#x3D; n &#x3D;&gt; Math.floor(n)

/**
 * Rounds &#x60;n&#x60; up to the nearest integer
 * @param {number} n
 * @returns {number}
 */
math_utils.ceil &#x3D; n &#x3D;&gt; Math.ceil(n)

/**
 * Rounds &#x60;n&#x60; to the nearest integer
 * @param {number} n
 * @returns {number}
 */
math_utils.round &#x3D; n &#x3D;&gt; Math.round(n)

/**
 * Wraps &#x60;index&#x60; around &#x60;length&#x60; (for indexing into to arrays, strings, etc.)
 * @param {number} index
 * @param {number} length
 * @returns {number}
 */
math_utils.wrapindex &#x3D; (index, length) &#x3D;&gt; (index % length + length) % length

/**
 * Clamps &#x60;n&#x60; between &#x60;min&#x60; and &#x60;max&#x60;
 * @param {number} n
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */
math_utils.clamp &#x3D; (n, min, max) &#x3D;&gt; Math.min(Math.max(n, min), max)

/**
 * Checks if &#x60;n&#x60; is in the range [&#x60;min&#x60;, &#x60;max&#x60;] (inclusive)
 * @param {number} n
 * @param {number} min
 * @param {number} max
 * @returns {boolean}
 */
math_utils.inrange &#x3D; (n, min, max) &#x3D;&gt; n &gt;&#x3D; min &amp;amp;&amp;amp; n &amp;lt;&#x3D; max

/**
 * Functions which operate on iterable types
 * @namespace
 */
const iter_utils &#x3D; {}

/**
 * Gets the first &#x60;n&#x60; elements of an iterable value and returns them in an array
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to get elements from
 * @param {number} n The number of elements to get
 * @returns {T[]}
 */
iter_utils.firstn &#x3D; (iter, n) &#x3D;&gt; [...iter].slice(0, n)

/**
 * Gets the last &#x60;n&#x60; elements of an iterable value and returns them in an array
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to get elements from
 * @param {number} n The number of elements to get
 * @returns {T[]}
 */
iter_utils.lastn &#x3D; (iter, n) &#x3D;&gt; !n ? [] : [...iter].slice(-n)

/**
 * Gets the first element of an iterable value
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to get the first element from
 * @returns {any}
 */
iter_utils.first &#x3D; iter &#x3D;&gt; [...iter][0]

/**
 * Gets the last element of an iterable value
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to get the last element from
 * @returns {any}
 */
iter_utils.last &#x3D; iter &#x3D;&gt; {
	const array &#x3D; [...iter]
	return array[array.length - 1]
}

/**
 * Removes the nth element from an iterable value
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to remove an element from
 * @param {number} index The index of the element to remove
 * @returns {T[]} The resulting array
 */
iter_utils.dropnth &#x3D; (iter, index) &#x3D;&gt; {
	const array &#x3D; [...iter]
	array.splice(math_utils.wrapindex(index, array.length), 1)
	return array
};

/**
 * Sums the elements of an iterable value
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to sum
 * @returns {number|string}
 */
iter_utils.sum &#x3D; iter &#x3D;&gt; [...iter].reduce((acc, cur) &#x3D;&gt; acc + cur)

/**
 * Calculates the product of all values in an iterable
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable
 * @returns {number}
 */
iter_utils.prod &#x3D; iter &#x3D;&gt; [...iter].reduce((acc, cur) &#x3D;&gt; acc * cur)

/**
 * Reverses the elements of an iterable (not in place)
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to reverse
 * @returns {T[]} The reversed array
 */
iter_utils.rev &#x3D; iter &#x3D;&gt; [...iter].reverse()

/**
 * **[Global]** Zips multiple iterable into a single array of arrays, each
 * containing a single element from each iterable. The result will only be as
 * long as the shortest input.
 * @template T
 * @function
 * @param {...Iterable.&amp;lt;T[]&gt;} iters The iterables to zip
 * @returns {T[][]}
 * @example zip([1, 2, 3], [4, 5, 6]) // [[1, 4], [2, 5], [3, 6]]
 * @example zip([1, 2]) // [[1], [2]]
 */
iter_utils.zip &#x3D; tag({ keep_global: true }, (...iters) &#x3D;&gt; {
	if (!iters.length) return [];

	const smallest &#x3D; Math.min(...iters.map(x &#x3D;&gt; x.length))
	const ret &#x3D; [];

	for (let i &#x3D; 0; i &amp;lt; smallest; i++) {
		ret.push(iters.map(x &#x3D;&gt; x[i]));
	}

	return ret;
})

/**
 * Creates a new {@link _Set} from an iterable. Same as {@link constructors.set}.
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to create a set from
 * @returns {_Set}
 */
iter_utils.uniq &#x3D; iter &#x3D;&gt; new _Set(iter)

/**
 * Sorts an iterable given a comparison function (same as [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort))
 * but not in place
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to sort
 * @param {function(T, T): number} compare_fn The comparison function
 * @returns {T[]} The sorted array
 */
iter_utils.sorted &#x3D; (iter, compare_fn) &#x3D;&gt; [...iter].sort(compare_fn)

/**
 * Sorts an iterable (of numbers) in ascending order
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to sort
 * @returns {T[]} The sorted array
 */
iter_utils.nsort &#x3D; iter &#x3D;&gt; [...iter].sort((a, b) &#x3D;&gt; a - b)

/**
 * Sorts an iterable (of numbers) in descending order
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to sort
 * @returns {T[]} The sorted array
 */
iter_utils.rsort &#x3D; iter &#x3D;&gt; [...iter].sort((a, b) &#x3D;&gt; b - a)

/**
 * Sorts an iterable in ascending order by the result of applying a given
 * function to each element
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to sort
 * @param {function(T)} func The function to apply to each element
 * @returns {T[]} The sorted array
 */
iter_utils.sortby &#x3D; (iter, func) &#x3D;&gt; iter.sort((a, b) &#x3D;&gt; func(a) - func(b))

/**
 * Sorts an iterable in descending order by the result of applying a given
 * function to each element
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to sort
 * @param {function(T)} func The function to apply to each element
 * @returns {T[]} The sorted array
 */
iter_utils.rsortby &#x3D; (iter, func) &#x3D;&gt; iter.sort((a, b) &#x3D;&gt; func(b) - func(a))

/** 
 * Same as the built in [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to iterate over
 * @param {function(T, number, Iterable.&amp;lt;T&gt;)} callback The callback to call for each element (see the MDN link for more info)
 * @returns {Iterable.&amp;lt;T&gt;} The original iterable
 */
iter_utils.for &#x3D; (iter, callback) &#x3D;&gt; {
	[...iter].forEach(callback)
	return iter
}

/** 
 * Same as the built in [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
 * @function
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to iterate over
 * @param {function(T, number, Iterable.&amp;lt;T&gt;)} callback The callback to call for each element (see the MDN link for more info)
 * @returns {Iterable.&amp;lt;T&gt;} The original iterable
 */
iter_utils.each &#x3D; iter_utils.for

/**
 * Same as the built in [Math.min](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min)
 * but it takes an iterable as a single argument
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to find the minimum of
 * @returns {number}
 */
iter_utils.min &#x3D; iter &#x3D;&gt; Math.min(...iter)

/**
 * Same as the built in [Math.max](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max)
 * but it takes an iterable as a single argument
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to find the maximum of
 * @returns {number}
 */
iter_utils.max &#x3D; iter &#x3D;&gt; Math.max(...iter)

/**
 * Same as the built in [Array.push](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
 * @template T
 * @param {T[]} array The array to append to
 * @param {...T} items The items to append
 * @returns {T[]} The resulting array
 */
iter_utils.append &#x3D; (array, ...items) &#x3D;&gt; (array.push(...items), array)

/**
 * Same as the built in [Array.unshift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
 * @template T
 * @param {T[]} array The array to prepend to
 * @param {...T} items The items to prepend
 * @returns {T[]} The resulting array
 */
iter_utils.prepend &#x3D; (array, ...items) &#x3D;&gt; (array.unshift(...items), array)

/**
 * Checks if all items in an iterable are equal
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to check
 * @returns {boolean}
 */
iter_utils.alleq &#x3D; iter &#x3D;&gt; {
	const array &#x3D; [...iter]
	return array.every(item &#x3D;&gt; misc_utils.eq(item, array[0]))
}

/**
 * Creates a list of sublists of length &#x60;size&#x60; each of which is a sliding
 * window looking into &#x60;iter&#x60; starting at index &#x60;0&#x60; moving along by 1 each
 * time. If &#x60;loop&#x60; is true, there will be some extra windows at the end which
 * wrap around to the start.
 * @template T
 * @param {Iterable.&amp;lt;T[]&gt;} iter The iterable to create sliding windows from
 * @param {number} size The size of the sliding window
 * @param {boolean} [wrap&#x3D;false] Whether to include windows that wrap around
 * @returns {T[][]}
 * @example [1, 2, 3, 4, 5].sliding(3) // [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
 * @example [1, 2, 3].sliding(2, true) // [[1, 2], [2, 3], [3, 1]]
 */
iter_utils.sliding &#x3D; (iter, size &#x3D; 2, wrap &#x3D; false) &#x3D;&gt; {
	const array &#x3D; [...iter]
	if (array.length &amp;lt; size) return []
	const x &#x3D; wrap ? array.concat(array.slice(0, size - 1)) : array
	return x.slice(0, -size + 1).map((_, i) &#x3D;&gt; x.slice(i, i + size))
}

/**
 * Creates a list of contiguous non-overlapping chunks of &#x60;iter&#x60;, each of
 * length &#x60;size&#x60;
 * @template T
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to create chunks from
 * @param {number} [size&#x3D;2] The size of each chunk
 * @returns {T[][]}
 * @example [1, 2, 3, 4, 5, 6].chunks() // [[1, 2], [3, 4], [5, 6]]
 * @example [1, 2, 3, 4, 5, 6].chunks(3) // [[1, 2, 3], [4, 5, 6]]
 */
iter_utils.chunks &#x3D; (iter, size &#x3D; 2) &#x3D;&gt; {
	const ret &#x3D; []
	for (let i &#x3D; 0; i &amp;lt; iter.length; i +&#x3D; size) {
		ret.push(iter.slice(i, i + size))
	}
	return ret
}

/**
 * Swaps the elements at indices &#x60;index_a&#x60; and &#x60;index_b&#x60; in &#x60;array&#x60;. Only works
 * on arrays so that it can be done in place.
 * @template T
 * @param {T[]} array The array to swap elements in
 * @param {number} index_a The index of the first element to swap
 * @param {number} index_b The index of the second element to swap
 * @returns {T[]} The resulting array
 */
iter_utils.swap &#x3D; (array, index_a, index_b) &#x3D;&gt; {
	[array[index_a], array[index_b]] &#x3D; [array[index_b], array[index_a]]
	return array
}

/**
 * Generates all permutations of an iterable
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter
 * @returns {T[][]}
 */
iter_utils.perms &#x3D; iter &#x3D;&gt; {
	const array &#x3D; [...iter]
	if (!array.length) return []

	const output &#x3D; []

	const generate &#x3D; (k, array) &#x3D;&gt; {
		if (k &#x3D;&#x3D;&#x3D; 1) {
			output.push(array.slice())
			return
		}

		generate(k - 1, array)

		for (let i &#x3D; 0; i &amp;lt; k - 1; i++) {
			if (k % 2 &#x3D;&#x3D;&#x3D; 0) iter_utils.swap(array, i, k - 1)
			else iter_utils.swap(array, 0, k - 1)
			generate(k - 1, array)
		}
	}

	generate(array.length, array)
	return output
}

/**
 * Return a list with every &#x60;n&#x60;th element of &#x60;iter&#x60; starting at index &#x60;start&#x60;
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to get elements from
 * @param {number} n The step size
 * @param {number} [start&#x3D;0] The starting index
 * @returns {T[]}
 */
iter_utils.everynth &#x3D; (iter, n, start &#x3D; 0) &#x3D;&gt; {
	const ret &#x3D; [];
	for (let i &#x3D; start; i &amp;lt; iter.length; i +&#x3D; n)
		ret.push(iter[i])
	return ret
}

/**
 * Gets the element at &#x60;index&#x60; in &#x60;iter&#x60;. Indices wrap around using
 * {@link math_utils.wrapindex}. If &#x60;index&#x60; is a {@link Vec}, &#x60;iter&#x60; will be
 * treated as a grid, or if &#x60;index&#x60; is a list of integers, a list of elements
 * at those indices will be returned.
 * @function
 * @template T
 * @param {Iterable.&amp;lt;T|Iterable.&amp;lt;T&gt;&gt;} iter The iterable to get elements from
 * @param {number|Vec|number[]} index The index/indicies to get
 * @returns {T}
 */
iter_utils.at &#x3D; tag({ attach_to: [Array] }, (iter, index) &#x3D;&gt; {
	const array &#x3D; [...iter]

	if (type_checks.isint(index)) {
		return array[math_utils.wrapindex(index, array.length)];
	} else if (index instanceof Vec) {
		return iter?.[index.y]?.[index.x]
	} else if (type_checks.isarr(index) &amp;amp;&amp;amp; index.every(type_checks.isint)) {
		return index.map(i &#x3D;&gt; iter_utils.at(array, i));
	} else {
		throw new Error(&#x60;Invalid index/indicies ${JSON.stringify(index)}&#x60;);
	}
})

const count &#x3D; (iter, value, string_like_match &#x3D; false, overlapping &#x3D; false) &#x3D;&gt; {
	const array &#x3D; [...iter]
	if (typeof value &#x3D;&#x3D;&#x3D; &quot;function&quot;) return array.filter(value).length

	string_like_match &#x3D; type_checks.isstr(iter) || string_like_match

	if (type_checks.isiter(value) &amp;amp;&amp;amp; string_like_match) {
		const to_find &#x3D; [...value]
		let count &#x3D; 0

		for (let i &#x3D; 0; i &amp;lt; array.length;) {
			if (misc_utils.eq(array.slice(i, i + to_find.length), to_find)) {
				count++
				i +&#x3D; overlapping ? 1 : to_find.length
			} else i++
		}

		return count
	}

	return array.filter(x &#x3D;&gt; misc_utils.eq(x, value)).length
}

/**
 * Counts the number of times &#x60;value&#x60; appears in &#x60;iter&#x60;. If &#x60;value&#x60; is a
 * function, it&#x27;s will do the same as &#x60;.filter(f).length&#x60;, if &#x60;iter&#x60; is a
 * string or &#x60;string_like_match&#x60; is explicitly set to &#x60;true&#x60;, &#x60;[&quot;a&quot;, &quot;b&quot;]&#x60; will
 * match &#x60;abcd&#x60; or [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] as well as something like 
 * [&quot;arstneio&quot;, [&quot;a&quot;, &quot;b], 4].
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to count values in
 * @param {any} value The value to count
 * @param {boolean} [string_like_match&#x3D;false] (See description)
 * @returns {number}
 * @example [4, 2, 3, 1, 2].count(2) // 2
 * @example &quot;abababa&quot;.count(&quot;aba&quot;) // 2
 * @example [3, 2, 1, 2, 1].count([2, 1]) // 0
 * @example [3, 2, 1, 2, 1].count([2, 1], true) // 2
 */
iter_utils.count &#x3D; (...args) &#x3D;&gt; count(...args)

/**
 * Same as &#x60;iter_utils.count&#x60; but counts overlapping matches
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to count values in
 * @param {any} value The value to count
 * @param {boolean} [string_like_match&#x3D;false] (See description)
 * @returns {number}
 * @example &quot;abababa&quot;.countol(&quot;aba&quot;) // 3
 * @example [1, 2, 1, 2, 1].countol([1, 2, 1]) // 2
 */
iter_utils.countol &#x3D; (iter, value, string_like_match &#x3D; false) &#x3D;&gt; count(iter, value, string_like_match, true)

/**
 * Same as the built in [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
 * but inverted. For consistency with builtins like &#x60;Array.filter&#x60; and &#x60;Array.map&#x60; which _don&#x27;t_ work on any iterable. This must also be called on an array.
 * @template T
 * @param {T[]} array The iterable to filter
 * @param {function(T): boolean} filter_fn The filter function
 * @returns {T[]}
 */
iter_utils.filterout &#x3D; (array, filter_fn) &#x3D;&gt; array.filter((...args) &#x3D;&gt; !filter_fn(...args))

/**
 * Checks if there are no elements in &#x60;array&#x60; that satisfy &#x60;fn&#x60;. &#x60;fn&#x60; is passed
 * to the built in [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
 * so refer to those docs if needed.
 * @template T
 * @param {T[]} array The array to check
 * @param {function(T, number, T[]): boolean} fn The function to check
 * @returns {boolean}
 */
iter_utils.none &#x3D; (array, fn) &#x3D;&gt; !array.some(fn)

/**
 * Gets the differences between consecutive elements of an iterable
 * @param {Iterable.&amp;lt;number&gt;} iter The iterable to get deltas from
 * @returns {number[]}
 * @example [1, 2, 9, -4].deltas // [1, 7, -13]
 */
iter_utils.deltas &#x3D; iter &#x3D;&gt; {
	const array &#x3D; [...iter];

	if (array.length &amp;lt;&#x3D; 1) return [];

	const ret &#x3D; [];
	for (let i &#x3D; 0; i &amp;lt; array.length - 1; i++) {
		ret.push(array[i + 1] - array[i]);
	}
	return ret;
}

/**
 * Splits an iterable into &#x60;n&#x60; pieces. Rounds up if the split is uneven.
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to split
 * @param {number} n The number of pieces to split into
 * @returns {T[][]}
 * @example [1, 2, 3, 4, 5, 6].pieces(3) // [[1, 2], [3, 4], [5, 6]]
 * @example [1, 2, 3].pieces(2) // [[1, 2], [3]]
 */
iter_utils.pieces &#x3D; (iter, n) &#x3D;&gt; {
	if (n &amp;lt;&#x3D; 0) return []
	const array &#x3D; [...iter], ret &#x3D; [], step &#x3D; Math.ceil(array.length / n);
	for (let i &#x3D; 0; i &amp;lt; array.length; i +&#x3D; step) {
		ret.push(array.slice(i, i + step))
	}
	return ret
}

/**
 * Returns list of indices where the function &#x60;fn&#x60; returns true. &#x60;fn&#x60; receives
 * the value, index and the iterable as arguments, in that order.
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter
 * @param {function(T, number, Iterable.&amp;lt;T&gt;): boolean} fn
 * @returns {number[]}
 * @example [1, 2, 3, 4, 5].iwhere(x &#x3D;&gt; x % 2 &#x3D;&#x3D;&#x3D; 0) // [1, 3]
 */
iter_utils.iwhere &#x3D; (iter, fn) &#x3D;&gt; [...iter]
	.map((value, index) &#x3D;&gt; [value, index])
	.filter(([value, index]) &#x3D;&gt; fn(value, index, iter))
	.map(([, index]) &#x3D;&gt; index)

/**
 * Returns a list of sublists containing consecutive elements of &#x60;iter&#x60;
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to group
 * @returns {T[][]}
 */
iter_utils.seqs &#x3D; iter &#x3D;&gt; {
	const ret &#x3D; []
	for (const value of iter) {
		if (ret[ret.length - 1]?.[ret[ret.length - 1].length - 1] &#x3D;&#x3D;&#x3D; value) {
			ret[ret.length - 1].push(value)
		} else {
			ret.push([value])
		}
	}
	return ret
}

/**
 * Checks if an iterable includes a value. Uses {@link iter_utils.count}.
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to check
 * @param {T} value The value to check for
 * @param {number} [start_index&#x3D;0] The index to start checking from
 * @returns {boolean}
 */
iter_utils.includes &#x3D; tag({ attach_to: [Array] }, (iter, value, start_index) &#x3D;&gt; {
	if (typeof iter &#x3D;&#x3D;&#x3D; &quot;string&quot;) return iter.includes(value, start_index)
	return [...iter].filter(x &#x3D;&gt; misc_utils.eq(x, value)).length &gt; 0
})


/** Alias for {@link iter_utils.includes}
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to check
 * @param {T} value The value to check for
 * @param {number} [start_index&#x3D;0] The index to start checking from
 * @returns {boolean}
 */
iter_utils.incl &#x3D; iter_utils.includes

/**
 * Deep flattens an iterable
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to flatten
 * @returns {T[]}
 * @example [[1, [2]], [[[[3, [4, 5]]]]], 6].flat // [1, 2, 3, 4, 5, 6]
 */
iter_utils.flat &#x3D; iter &#x3D;&gt; [...iter].flat(Infinity)

/**
 * Flattens an iterable to a certain depth. Alias for the builtin [Array.flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat).
 * @template T
 * @param {Iterable.&amp;lt;T&gt;} iter The iterable to flatten
 * @param {number} [depth&#x3D;1] The depth to flatten to
 * @returns {T[]}
 */
iter_utils.nflat &#x3D; (iter, depth &#x3D; 1) &#x3D;&gt; [...iter].flat(depth)

/** @namespace */
const string_utils &#x3D; {}

/**
 * Splits a string into an array of characters
 * @param {string} str The string to split
 * @returns {string[]}
 */
string_utils.chars &#x3D; str &#x3D;&gt; str.split(&quot;&quot;)

/**
 * Splits a string on spaces and trims each word
 * @param {string} str The string to split
 * @returns {string[]}
 */
string_utils.words &#x3D; str &#x3D;&gt; str.split(&quot; &quot;).map(s &#x3D;&gt; s.trim())

/**
 * Splits a string on &quot;\n&quot;
 * @param {string} str The string to split
 * @returns {string[]}
 */
string_utils.lines &#x3D; str &#x3D;&gt; str.split(&quot;\n&quot;)

/**
 * Splits a string on &quot;\n\n&quot;
 * @param {string} str The string to split
 * @returns {string[]}
 */
string_utils.groups &#x3D; str &#x3D;&gt; str.split(&quot;\n\n&quot;)

/**
 * Splits a string on commas and trims each element
 * @param {string} str The string to split
 * @returns {string[]}
 */
string_utils.csv &#x3D; str &#x3D;&gt; str.split(&quot;,&quot;).map(s &#x3D;&gt; s.trim())

/**
 * Checks if a character is a digit
 * @param {string} char The character to check
 * @returns {boolean}
 */
string_utils.isdigit &#x3D; char &#x3D;&gt; /^\d$/.test(char)

/**
 * Extracts all integers from a string and returns them in an array
 * @param {string} str The string to extract integers from
 * @returns {number[]}
 */
string_utils.ints &#x3D; str &#x3D;&gt; str.match(/-?\d+/g).map(type_casts.int)

/**
 * Extracts all numbers from a string and returns them in an array
 * @param {string} str The string to extract numbers from
 * @returns {number[]}
 */
string_utils.nums &#x3D; str &#x3D;&gt; str.match(/\d+(\.\d+)?/g).map(type_casts.num)

/**
 * Gets the ASCII code a character
 * @param {string} char The character to get the code of
 * @returns {number}
 */
string_utils.chcode &#x3D; char &#x3D;&gt; char.charCodeAt(0)

/**
 * Converts a string to upper case
 * @param {string} str The string to convert
 * @returns {string}
 */
string_utils.upper &#x3D; str &#x3D;&gt; str.toUpperCase()

/**
 * Converts a string to lower case
 * @param {string} str The string to convert
 * @returns {string}
 */
string_utils.lower &#x3D; str &#x3D;&gt; str.toLowerCase()

/** @namespace */
const logic_utils &#x3D; {}

/**
 * Returns &#x60;a &amp;amp;&amp;amp; b&#x60;. I.e. if &#x60;a&#x60; is truthy it returns &#x60;b&#x60;, otherwise it short
 * circuits and returns &#x60;a&#x60;
 * @param {any} a
 * @param {any} b
 * @returns {any}
 */
logic_utils.and &#x3D; (a, b) &#x3D;&gt; a &amp;amp;&amp;amp; b

/**
 * Returns &#x60;a || b&#x60;. I.e. if &#x60;a&#x60; is truthy it short circuits and returns &#x60;a&#x60;,
 * otherwise it returns &#x60;b&#x60;
 * @param {any} a
 * @param {any} b
 * @returns {any}
 */
logic_utils.or &#x3D; (a, b) &#x3D;&gt; a || b

/**
 * Returns logical NOT of &#x60;a&#x60;
 * @param {any} a
 * @returns {boolean}
 */
logic_utils.not &#x3D; a &#x3D;&gt; !a

/**
 * Returns logical XOR of &#x60;a&#x60; and &#x60;b&#x60;. I.e. returns true if exactly one of &#x60;a&#x60;
 * and &#x60;b&#x60; are truthy, otherwise returns false
 * @param {any} a
 * @param {any} b
 * @returns {boolean}
 */
logic_utils.xor &#x3D; (a, b) &#x3D;&gt; !!(!a ^ !b)

/** @namespace */
const grid_utils &#x3D; {}

/**
 * Creates a grid from a string where each row is separated by a newline and
 * each cell is seperated by &#x60;delim&#x60;.
 * @param {string} str The string to create a grid from
 * @param {string} delim The delimiter to split cells by
 * @returns {string[][]}
 */
grid_utils.gridd &#x3D; (str, delim) &#x3D;&gt; str.trim().split(&quot;\n&quot;).filter(x &#x3D;&gt; x).map(row &#x3D;&gt; row.split(delim).filter(x &#x3D;&gt; x))

/**
 * Calls with {@link grid_utils.gridd} with an empty delimiter
 * @param {string} str The string to create a grid from
 * @returns {string[][]}
 */
grid_utils.grid &#x3D; str &#x3D;&gt; grid_utils.gridd(str, &quot;&quot;)

/**
 * Uses {@link grid_utils.grid} then maps each cell to a number
 * @param {string} str The string to create a grid from
 * @returns {number[][]}
 */
grid_utils.digitgrid &#x3D; str &#x3D;&gt; grid_utils.grid(str).map(row &#x3D;&gt; row.map(cell &#x3D;&gt; +cell))

/**
 * Maps a function over each cell in a grid
 * @template T
 * @template K
 * @param {T[][]} grid The grid to map over
 * @param {function(T, Vec, T[][]): K} fn The function to map
 * @returns {K[][]}
 */
grid_utils.gmap &#x3D; (grid, fn) &#x3D;&gt; grid.map((row, y) &#x3D;&gt; row.map((cell, x) &#x3D;&gt; fn(cell, new Vec(x, y), grid)))

/**
 * Finds {@link Vec}s in a grid which satisfy the given function
 * @template T
 * @param {T[][]} grid The grid to search
 * @param {function(T, Vec, T[][]): boolean} fn The function to filter with
 * @returns {Vec[]}
 */
grid_utils.vecswhere &#x3D; (grid, fn) &#x3D;&gt; grid.flatMap(
	(row, y) &#x3D;&gt; row
		.map((cell, x) &#x3D;&gt; [cell, new Vec(x, y)])
		.filter(args &#x3D;&gt; fn(...args, grid))
		.map(([, vec]) &#x3D;&gt; vec)
)

/**
 * Rotates a grid 90 degrees clockwise &#x60;times&#x60; times
 * @param {T[][]} grid The grid to rotate
 * @param {number} [times&#x3D;1] The number of times to rotate
 * @returns {T[][]}
 */
grid_utils.nrotate &#x3D; (grid, times &#x3D; 1) &#x3D;&gt; {
	if (!grid.length) return []
	let ret &#x3D; grid.map(row &#x3D;&gt; row.slice())
	for (let i &#x3D; 0; i &amp;lt; times; i++) {
		ret &#x3D; ret[0].map((_, i) &#x3D;&gt; ret.map(row &#x3D;&gt; row[i]).reverse())
	}
	return ret
}

/**
 * Rotates a grid 90 degrees clockwise once (alias for &#x60;grid_utils.nrotate(grid, 1)&#x60;)
 * @param {T[][]} grid The grid to rotate
 * @returns {T[][]}
 */
grid_utils.rotate &#x3D; grid &#x3D;&gt; grid_utils.nrotate(grid, 1)

/**
 * Gets diagonals of a grid (top right to bottom left). Assumes the grid is rectangular.
 * @param {T[][]} grid The grid to get diagonals from
 * @returns {T[][]}
 * @example diagonals([
 *     [1, 2, 3],
 *     [4, 5, 6],
 *     [7, 8, 9]
 * ]) // [[1], [2, 4], [3, 5, 7], [6, 8], [9]]
 */
grid_utils.diagonals &#x3D; grid &#x3D;&gt; {
	const ret &#x3D; []

	for (let r &#x3D; 0; r &amp;lt; grid.length; r++) {
		for (let c &#x3D; 0; c &amp;lt; grid[0].length; c++) {
			ret[r + c] ??&#x3D; []
			ret[r + c].push(grid[r][c])
		}
	}

	return ret
}

/**
 * Gets diagonals of a grid in the other direction to {@link grid_utils.diagonals}
 * (so top left to bottom right). Assumes the grid is rectangular.
 * @param {T[][]} grid The grid to get diagonals from
 * @returns {T[][]}
 * @example antidiagonals([
 *     [1, 2, 3],
 *     [4, 5, 6],
 *     [7, 8, 9]
 * ]) // [[3], [2, 6], [1, 5, 9], [4, 8], [7]]
 */
grid_utils.antidiagonals &#x3D; grid &#x3D;&gt; {
	const ret &#x3D; [], width &#x3D; grid[0]?.length

	for (let r &#x3D; 0; r &amp;lt; grid.length; r++) {
		for (let c &#x3D; 0; c &amp;lt; width; c++) {
			ret[r + (width - 1 - c)] ??&#x3D; []
			ret[r + (width - 1 - c)].push(grid[r][c])
		}
	}

	return ret
}

/**
 * **[Global]** Creates a grid of size &#x60;width&#x60; by &#x60;height&#x60; filled with &#x60;fill&#x60;.
 * Fill defaults to &#x60;null&#x60;.
 * @template T
 * @param {number} width The width of the grid
 * @param {number} height The height of the grid
 * @param {T} [fill&#x3D;null] The value to fill the grid with
 * @returns {T[][]}
 */
grid_utils.emptygrid &#x3D; tag(
	{ keep_global: true },
	(width, height, fill &#x3D; null) &#x3D;&gt; Array(height).fill().map(() &#x3D;&gt; Array(width).fill(fill))
)

/**
 * **[Global]** Prints a grid and returns it. If the shortest cell is only 1 character long
 * then the grid will be printed without spaces between cells.
 * @function
 * @template T
 * @param {T[][]} grid
 * @returns {T[][]}
 */
grid_utils.gprint &#x3D; tag({ keep_global: true }, grid &#x3D;&gt; {
	const longest_cell &#x3D; Math.max(...grid.flatMap(
		row &#x3D;&gt; row.map(cell &#x3D;&gt; cell.toString().length)
	))

	console.log(grid.map(row &#x3D;&gt; row.map(
		cell &#x3D;&gt; cell.toString().padEnd(longest_cell)
	).join(longest_cell &gt; 1 ? &quot; &quot; : &quot;&quot;)).join(&quot;\n&quot;))

	return grid
})

/**
 * Alias for {@link grid_utils.gprint}
 * @template T
 * @param {T[][]} grid
 * @returns {T[][]}
 */
grid_utils.gpr &#x3D; grid &#x3D;&gt; grid_utils.gprint(grid)

/**
 * Sets value at the given vector in a grid. If the cell doesn&#x27;t exist, it will be created.
 * @template T
 * @param {T[][]} grid The grid to set the value in
 * @param {Vec} vec The vector to set the value at
 * @param {T} value The value to set
 * @returns {T[][]} The modified grid
 */
grid_utils.gset &#x3D; (grid, vec, value) &#x3D;&gt; {
	const row &#x3D; grid[vec.y]
	if (!row) grid[vec.y] &#x3D; []
	grid[vec.y][vec.x] &#x3D; value
	return grid
}

/**
 * Returns the first vector in a grid (searching top to bottom, left to right)
 * where the function &#x60;fn&#x60; is truthy for that cell. &#x60;fn&#x60; also receives the
 * position of each cell and a reference to the grid.
 * @template T
 * @param {T[][]} grid The grid to search
 * @param {function(T, Vec, T[][]): boolean} fn The function to search with
 * @returns {Vec}
 */
grid_utils.vecwhere &#x3D; (grid, fn) &#x3D;&gt; {
	for (let y &#x3D; 0; y &amp;lt; grid.length; y++) {
		for (let x &#x3D; 0; x &amp;lt; grid[y].length; x++) {
			if (fn(grid[y][x], new Vec(x, y), grid)) return new Vec(x, y)
		}
	}
	return null
}

/** @namespace */
const object_utils &#x3D; {}

/**
 * Same as the built in [Object.keys](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)
 * @param {object} obj The object to get keys from
 * @returns {string[]}
 */
object_utils.keys &#x3D; obj &#x3D;&gt; Object.keys(obj)

/**
 * Same as the built in [Object.values](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values)
 * @param {object} obj The object to get values from
 * @returns {any[]}
 */
object_utils.values &#x3D; obj &#x3D;&gt; Object.values(obj)

/**
 * Same as the built in [Object.entries](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)
 * @param {object} obj The object to get entries from
 * @returns {any[]} An array of key-value tuples
 */
object_utils.entries &#x3D; obj &#x3D;&gt; Object.entries(obj)

/** @namespace */
const misc_utils &#x3D; {}

/**
 * **[Global]** Checks &#x60;a&#x60; and &#x60;b&#x60; are equal. In theory this works for any two values,
 * whether they&#x27;re primitives, arrays or some other object.
 * @function
 * @param {any} a
 * @param {any} b
 * @returns {boolean}
 */
misc_utils.eq &#x3D; tag({ keep_global: true }, (a, b) &#x3D;&gt; {
	if (Array.isArray(a) &amp;amp;&amp;amp; Array.isArray(b)) {
		if (a.length !&#x3D;&#x3D; b.length) return false;
		for (let i &#x3D; 0; i &amp;lt; a.length; i++)
			if (!misc_utils.eq(a[i], b[i])) return false;
		return true;
	} else if (typeof a &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;amp;&amp;amp; typeof b &#x3D;&#x3D;&#x3D; &quot;object&quot;) {
		return JSON.stringify(a) &#x3D;&#x3D;&#x3D; JSON.stringify(b);
	} else return a &#x3D;&#x3D;&#x3D; b;
})

/** 
 * **[Global]** Checks &#x60;a&#x60; and &#x60;b&#x60; are not equal (by negating &#x60;misc_utils.eq&#x60;)
 * @function
 * @param {any} a
 * @param {any} b
 * @returns {boolean}
 */
misc_utils.neq &#x3D; tag({ keep_global: true }, (a, b) &#x3D;&gt; !eq(a, b))

/**
 * **[Global]** Creates the range &#x60;[a, b)&#x60; in an array with an optional step size
 * @function
 * @param {number} a End of the range (if &#x60;b&#x60; is not provided)
 * @param {number} [b&#x3D;0] End of the range (if provided, in which case &#x60;a&#x60; is the start)
 * @param {number} [step&#x3D;1]
 * @returns {number[]}
 * @example range(4) // [0, 1, 2, 3]
 * @example range(2, 5) // [2, 3, 4]
 * @example range(1, 10, 2) // [1, 3, 5, 7, 9]
 */
misc_utils.range &#x3D; tag({ keep_global: true }, function(a, b &#x3D; 0, step &#x3D; 1) {
	let start &#x3D; 0, end &#x3D; a
	if (arguments.length &gt; 1) {
		start &#x3D; a
		end &#x3D; b
	}
	const ret &#x3D; [];
	for (let n &#x3D; start; n &amp;lt; end; n +&#x3D; step)
		ret.push(n)
	return ret
})

/**
 * **[Global]** Same as &#x60;console.log&#x60; its arg(s)
 * @function
 * @template T
 * @param {...T} values Values to print
 * @returns {T|T[]}
 */
misc_utils.print &#x3D; tag({ keep_global: true }, (...values) &#x3D;&gt; {
	console.log(...values)
	return values.length &gt; 1 ? values : values[0]
})

/**
 * **[Global]** Same as &#x60;misc_utils.print&#x60; but niladic (so that it becomes a getter)
 * @template T
 * @param {T} value Value to print
 * @returns {T}
 */
misc_utils.pr &#x3D; value &#x3D;&gt; misc_utils.print(value)

/**
 * **[Global]** Tries to get the length property of &#x60;value&#x60; otherwise tries to get &#x60;size&#x60;
 * @function
 * @param {any} value Value to get the length/size of
 * @returns {?number}
 */
misc_utils.len &#x3D; value &#x3D;&gt; value?.length ?? value?.size

/**
 * Wraps a value in a singleton list
 * @function
 * @template T
 * @param {T} value Value to wrap
 * @returns {T[]}
 */
misc_utils.wrap &#x3D; value &#x3D;&gt; [value]

/**
 * Finds the number of corners in an area
 * @param {_Set&amp;lt;Vec&gt;} area The area to find corners in
 * @returns {number}
 */
misc_utils.corners &#x3D; area &#x3D;&gt; {
	const xs &#x3D; [...area].map(v &#x3D;&gt; v.x)
	const ys &#x3D; [...area].map(v &#x3D;&gt; v.y)

	let corners &#x3D; 0

	for (let x &#x3D; Math.min(...xs) - 1; x &amp;lt;&#x3D; Math.max(...xs); x++) {
		for (let y &#x3D; Math.min(...ys) - 1; y &amp;lt;&#x3D; Math.max(...ys); y++) {
			const subgrid &#x3D; [new Vec(x, y), new Vec(x + 1, y), new Vec(x, y + 1), new Vec(x + 1, y + 1)]
			const in_area &#x3D; subgrid.map(v &#x3D;&gt; area.has(v))
			const count_in_area &#x3D; in_area.filter(x &#x3D;&gt; x).length
			if (count_in_area &#x3D;&#x3D; 1 || count_in_area &#x3D;&#x3D; 3) corners++
			else if (
				misc_utils.eq(in_area, [true, false, false, true]) ||
				misc_utils.eq(in_area, [false, true, true, false])
			) corners +&#x3D; 2
		}
	}

	return corners
}

/** @namespace */
const constructors &#x3D; {}

/**
 * **[Global]** Calls &#x60;new _Set(iter)&#x60;. See the documentation for &#x60;{@link _Set}&#x60; for more info
 * @function
 * @param {Iterable.&amp;lt;*&gt;} iter The iterable to create the set from
 * @returns {_Set}
 */
constructors.S &#x3D; tag({ keep_global: true }, (iter &#x3D; []) &#x3D;&gt; new _Set(iter))

/**
 * **[Global]** Calls &#x60;new Vec(x, y)&#x60;. See the documentation for &#x60;{@link Vec}&#x60; for more info
 * @function
 * @param {number} x The x component of the vector
 * @param {number} y The y component of the vector
 * @returns {Vec}
 */
constructors.V &#x3D; tag({ keep_global: true }, (x, y) &#x3D;&gt; new Vec(x, y))

export default {
	...type_checks,
	...type_casts,
	...math_utils,
	...string_utils,
	...iter_utils,
	...object_utils,
	...logic_utils,
	...grid_utils,
	...misc_utils,
	...constructors
}
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 4.0.4 on December 19, 2024.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>